#!/usr/bin/perl
=head1 Description

        This pipeline is to use kgf to fill gaps. kgf is a new gap filling program, based on PE reads and gap edge related reads. All the reads assembled by overlap method. This pipeline contains collecting gap related reads, reads filter, gap filling gap analysis, filling gaps  and filling result analysis.
	To get gap related reads, there are two choise. You can use krs to map sequencing reads to raw scaffold sequences, or use SOAPdenovo reads mapping result. It is suggested to use the reads abtained from SOAPdenovo map step.

=cut 
=head1 Contact and Version
        Contact: Assemble Development Team(ADT).
        Version: 1.19
=cut
=head1 Usage
  
	perl krskgf.pl [options]
	basical argument :
  	--scaf		<str>	set scaffold sequence. step 1 must. 
 	--lib		<str>	set library file. step 1 must.
  	--contig	<str>	set contig sequence. step 2.
	--gapread	<str>	set gap reads. step 2.
	--outdir	<str>	set the output directory , no default 
	--match		<float> set the match ratio of reads to contig , default=0.98   
	--step		<int>	set steps. 1: get reads using krs.  2: contig gap filling 3: fill result analysis. default=123.
  	--kmer		<int>   set the kmer-size when krs map .
  	--thread	<int>	set thread number for kgf gap filling, default =8.
  	--cpu		<int>	set scaffolds cut number for kgf gapfilling step, default=4.
  
  	qsub argument :
  	--P		<str>   set the qsub -P , must be set if qsub the work script , No default(user can custom by modifying the variant $P ) .
  	--queue		<str>   set the qsub queue , no default .
  	--vf		<str>	set vf for kgf.sh.
  	--noqsub	<...>   set when user need to run the scripts local ,default qsub .

  	no frequent set argument:
  	--maxreadlen  	<int>   set the longest read length for kgf , default 100.
  	--contiglen	<int>	set contig length cutoff, when contig length is less than it, the contig will be masked into gap region , default 70.
  	--debug		<...>   set for advantage debug , output more information , default No-debug.

  	--verbose     		output verbose information to screen  
  	--help        		output help information to screen
=cut

=head1
Description:

	this pipeline is divided into 3 steps , user will see directory "step_1/step_2/step_3" for each steps , each step directory contains the files generated by this step . follow lists the file of each step :
	step_1: map.sh map.log gapread.fa gapread.fa.ER.lst gapread.fa.gapread.depth gapread.fa.stat 
	step_2: F*/ kgf.sh *.fill *.fill.scaftig *.CONTIG N50.txt gapSeq.fa 
	step_3: canfill.stat canfullfill.lst cover.lst blank.lst ER.lst TR.lst 
	
	see the manaul for more information . 
=cut
=head1 examples
	perl krskgf.pl --scaf /path/*.scafSeq --lib /path/*.cfg(lib) --outdir /path/dir_to_output_result --kmer kmer_size --thread thread_num --cpu file_cuted_num --P Project_Name --queue qsub_queue  --step 1/12/123 >fill.log 
	perl krskgf.pl --contig /path/*.SCAF.contig --gapread /path/gapread.fa --outdir /path/dir_to_output_result --thread thread_num --cpu file_cuted_num --P Project_Name  --queue qsub_queue --step 2 >fill.log
	perl krskgf.pl --outdir /path/dir_to_output_result --step 3 >fill.log (note: this step depends to step_1 and step_2 , please ensure current directory can find them!)
=cut
use strict;
use Getopt::Long;
use File::Basename;
use Data::Dumper;
use FindBin qw($Bin);

my ($path,$krs,$kgf2) = ("$Bin/stat2","$Bin/krs","$Bin/kgf1.19");

my ($scaffold_file,$lib_file,$contig_file,$gapread_file,$dir,$prefix,$debug,$noqsub,$kmer,$readlength , $queue);
my ($cpu,$step, $Help, $Outdir, $Verbose, $thread, $startid,$scafnum, $kvf, $len, $vf, $longread, 
	$kmer, $contigcutoff , $P , $match_ratio);
GetOptions(
	"scaf:s"=>\$scaffold_file,
	"lib:s"=>\$lib_file,
	"dir:s"=>\$dir,
	"prefix:s"=>\$prefix,
	"contig:s"=>\$contig_file,
	"gapread:s"=>\$gapread_file,
	"maxreadlen:i"=>\$readlength ,
	"contiglen:i"=>\$contigcutoff,
	"cpu:i"=>\$cpu,
	"match:f"=>\$match_ratio ,
	"queue:s"=>\$queue ,
	"kmer:i"=>\$kmer,
	"vf:s"=>\$kvf,
	"P:s"=>\$P,
	"step:i"=>\$step,
	"thread:i"=>\$thread,
	"lrs:i"=>\$longread,
	"outdir:s"=>\$Outdir,
	"debug!"=>\$debug,
	"noqsub!"=>\$noqsub,
	"verbose"=>\$Verbose,
	"help"=>\$Help
);

#$Outdir ||= ".";  #12-4-24
$cpu ||= 4;
$step ||=123;
$thread ||=4;
$startid ||=0;
$kvf ||="0G";
$scafnum ||=0;
$match_ratio ||=0.98 ;
$longread ||=0;
$kmer ||=31;
$readlength ||= 100 ;
$contigcutoff ||= 100 - 31;
#$IsGz ||= 0 ;
my ($scaf,$scafSeq,$reads,$PEreads,$Rlongread,$totalread,$scafcontig);

die `pod2text $0` if ($Help);
die `pod2text $0` unless (-d $Outdir) ;

#sub abs_path
#############
#2011-5-26
#sub abs_path
#{
#	chomp(my $tem_dir = `pwd`);
#	foreach(@_){
#		$_ || next ;
#		/^\// && next ;
#		$_ =~ s/^\.//g if(/^\./) ; 
#		$_ = "$tem_dir/$_";
#		s/\/+$//g;
#	}
#}

sub abs_path
{
	chomp(my $tem_dir = `pwd`) ;
	foreach(@_)
	{
		$_ || next ;
		/^\// && next ;
		my ($f,$d,$s) = fileparse($_);
		$d =~ s/\/$// ;
		$_ = "$tem_dir/$d/$f";
		$_ =~ s/\/+$//g ;
	}
}

#############
abs_path($Outdir,$lib_file,$scaffold_file,$contig_file,$gapread_file);
mkdir $Outdir unless (-d $Outdir);
my $size=0;

print "Starting kgf gap filling , with step: $step\n";
#sub get_mem
############
#2011-5-26
sub get_mem
{
    	chomp(my $user = `whoami`);
	chomp(my @Qlst = `qstat -g c -U $user | awk '{x++}(x>2){print \$1}'`);
	foreach(@Qlst){
		/mem\.q/ && return(" --queue $_");		
	}
	0;
}
###########
#my $able_mem = get_mem();

if($scaffold_file)
{
	my @names=split (/\//,$scaffold_file);
	my $name = $names[@names -1];
	my $file = "$Outdir/$name";
	if(-e $file)
	{
		$scaffold_file = $file;
	}else{
		print "link scafSeq to outdir!\n";
		`ln -s $scaffold_file $Outdir/$name`;
		$scaffold_file = $file;
	}
}

my $doc_step1 = "step_1";
my $doc_step2 = "step_2";
my $doc_step3 = "step_3";

if($step =~ /1/){
	unless(-d "$Outdir/$doc_step1")
	{ `mkdir $Outdir/$doc_step1` ;}
	
	print "Step one: get reads using krs!\n";
	die `pod2text $0` if(!$scaffold_file || !$lib_file);

	my $line= `perl $path/splitscaf.pl $scaffold_file `;
	$scafcontig = "$scaffold_file.SCAF.contig" ;
	`perl $path/get_scafcontig.pl $scaffold_file.SCAF >$scafcontig` ;
	`rm $scaffold_file.SCAF` ;
	($scafnum,$len) = split /\t/,$line;
	$vf = int(int($len *4 /3 *24)/1000000000) + 1;

	my $break=0;
	if($vf > 20)
	{$break =1;}
	$vf=$vf."G";

	print "vf: $vf\n";
	$size = int($len*4/3) + 1;
	open WR,">$Outdir/$doc_step1/map.sh";

	print WR "$krs -c $scafcontig -l $lib_file -M $match_ratio -k $kmer -o $Outdir/$doc_step1/gapread.fa -m $size -t $thread -r $readlength -L $contigcutoff 2>$Outdir/$doc_step1/map.log\n";
	
	if($noqsub){
		`sh $Outdir/$doc_step1/map.sh`;
	}else{
		`nohup $path/qsub-sge.pl --resource="vf=$vf -P $P -q $queue" --maxjob 1 --jobprefix map --convert no $Outdir/$doc_step1/map.sh`;
	}
	close WR;
	
	$contig_file="$scaffold_file.SCAF.contig";
	$gapread_file="$Outdir/$doc_step1/gapread.fa";
	`perl $path/readstat2.pl $gapread_file >$Outdir/$doc_step1/gapread.fa.stat`;
	
	print "Step one finished!\n";
}


if($step=~/2/ && $cpu > 1)
{
	unless (-d "$Outdir/$doc_step2"){`mkdir $Outdir/$doc_step2`;}
	my $nowname ;
    	print "Cut the files and kgf gap filling!";
	if(!$contig_file)
	{

		$scaffold_file =~ s/\.SCAF$//g;
		$contig_file = "$scaffold_file.SCAF.contig";
		$nowname = basename($contig_file);
		$nowname =~ s/\.SCAF\.contig//g;
		`mv $contig_file $Outdir/$doc_step2` ;
		$contig_file = "$Outdir/$doc_step2/$nowname" ;
		unless (-e $contig_file)
		{
			print "please make sure the progrom can find the file $scaffold_file.SCAF.contig in this work directory!\n";
		}
	}else{
		$scaffold_file =$contig_file;
		$nowname = basename($contig_file) ;
		$nowname =~ s/\.SCAF\.contig//g;
		$scaffold_file =~ s/\.SCAF\.contig//g;
	}
	#$gapread_file="$Outdir/gapread.fa" if(!$gapread_file);
	$gapread_file="$Outdir/$doc_step1/gapread.fa" if(!$gapread_file);
	
	if(-e $gapread_file && -e $contig_file)
	{
		print "Load gap file: $gapread_file.\nLoad contig file: $contig_file.\n";
	}else{
		print "Please input or check $gapread_file or $contig_file!\n";
	}
	`perl $path/Cut2.pl $gapread_file $contig_file $cpu $Outdir/$doc_step2`;
	`perl $path/Creatkgf.pl $kgf2 $Outdir/$doc_step2 $cpu $thread >$Outdir/$doc_step2/kgf.sh`;
	if($kvf eq '0G')
	{
		$kvf=$thread*2 + int($len/1000000000/$cpu);
		$kvf=$kvf."G";
	}
	print "kvf: $kvf\n";

	if($noqsub){
		`sh $Outdir/$doc_step2/kgf.sh`;
	}else{
		`nohup $path/qsub-sge.pl --resource="vf=$kvf -P $P -q $queue" --maxjob $cpu --jobprefix map --convert no $Outdir/$doc_step2/kgf.sh`; #6-22
	}
	
	`mv $scaffold_file.CONTIG $Outdir/$doc_step2/` ;
	my $scaffname = $nowname ;
	`cat $Outdir/$doc_step2/F*/FilledScaf/seq.thread* $Outdir/$doc_step2/$scaffname.CONTIG >$Outdir/$doc_step2/$scaffname.fill`;

	my $seq = "$Outdir/$doc_step2/gapSeq.fa";
	`cat $Outdir/$doc_step2/F*/gapSeq.fa > $seq`;
	`perl $path/get_scaftig.pl $Outdir/$doc_step2/$scaffname.fill >$Outdir/$doc_step2/$scaffname.fill.scaftig`;
	`perl $path/seq_n50 $Outdir/$doc_step2/$scaffname.fill.scaftig >$Outdir/$doc_step2/N50.txt`;

	my $fill = `perl $path/gapfillratio2.pl $Outdir/$doc_step2 $cpu`;
	if($fill=~ /Error/)
	{
		print "\n\n$fill\n\n";
		exit(1);
	}								              
	print $fill;
	print "Gap filling finished! \n";

}else{
	print STDERR "set --cpu larger than 1 , or kgf will cost more memory and time !\n" ;
}

if($step =~ /3/)
{
    	unless(-d "$Outdir/$doc_step3") {`mkdir $Outdir/$doc_step3`;} 
	print "Step Three: analysis the fill result!\n";
	my $depth ;
    	$gapread_file = "$Outdir/$doc_step1/gapread.fa";
	$depth = "$Outdir/$doc_step1/gapread.fa.gapread.depth";
	unless(-e $depth){
		`perl $path/readstat2.pl $gapread_file >$Outdir/$doc_step3/gapread.fa.stat`;
    	}
	my $seq = "$Outdir/$doc_step2/gapSeq.fa";
	my $Log = "$Outdir/$doc_step3/fill.Log"	;
	`cat $Outdir/$doc_step2/F*/Log/log.thread* >$Log` ;
	if(!$depth || !$seq || !$Log) 
	{
		print "please check file: $depth and $seq \n";
		exit(1);
	}
	`grep 'TRGAP' $Log >$Outdir/$doc_step3/TR.lst`;
	`grep 'ERGAP' $Log >$Outdir/$doc_step3/ER.lst`;
	`rm $Log` ;
	`perl $path/blank.pl $depth $seq >$Outdir/$doc_step3/blank.lst`;
	`perl $path/covercheck.pl $Outdir/$doc_step3/blank.lst >$Outdir/$doc_step3/cover.lst`;
	#`more $Outdir/cover.lst |awk '$3 < 1 {print $_}' >$Outdir/uncover.lst`;
	`perl $path/gether.pl $Outdir/$doc_step3/cover.lst $Outdir/$doc_step3/TR.lst $depth $Outdir/$doc_step3/ER.lst >$Outdir/$doc_step3/canfill.stat`;
	`mv $Outdir/canfullfill.lst $Outdir/$doc_step3` ;
	print "Fill analysis finished! Please read file: canfill.stat \n";
}


print "All Pipeline finished!";
