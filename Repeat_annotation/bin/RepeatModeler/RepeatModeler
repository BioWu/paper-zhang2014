#!/usr/bin/perl
##---------------------------------------------------------------------------##
##  File:
##      @(#) RepeatModeler
##  Author:
##      Arian Smit <asmit@systemsbiology.org>
##      Robert Hubley <rhubley@systemsbiology.org>
##  Description:
##      Takes one or more DNA sequence files, in fasta format, and returns
##      the consensus models of putative repeats.
##
#******************************************************************************
#* Copyright (C) Institute for Systems Biology 2008 Developed by
#* Arian Smit and Robert Hubley.
#*
#* This work is licensed under the Open Source License v2.1.  To view a copy
#* of this license, visit http://www.opensource.org/licenses/osl-2.1.php or
#* see the license.txt file contained in this distribution.
#*
###############################################################################
#  ChangeLog:
#
#    $Log: RepeatModeler,v $
#    Revision 1.57  2011/06/06 18:56:11  rhubley
#    Cleanup before a distribution
#
#
###############################################################################
#
# To Do:
#
#./makeblastdb -in sampleDB-2.fa -dbtype nucl -out s1
#
#cat sampleDB-2.fa | perl -ne '{ if ( $seq eq "" ) { $seq = 1; } if ( /^>(.*)/ )
#{ print ">gi\|$seq\| $1\n"; $seq++; } else { print $_; } }' > sampleDB-2-gi.fa
#./makeblastdb -in sampleDB-2-gi.fa -parse_seqids -dbtype nucl -out s1
#/usr/local/rmblast/blastdbcmd -db s1 -entry all -outfmt "%t %g"
#./blastdb_aliastool -gi_file_in s1_limit1
#./blastdbcmd -db s1 -entry 1 -range 0-9
#
#

=head1 NAME

RepeatModeler - Model repetitive DNA

=head1 SYNOPSIS

  RepeatModeler [-options] -database <XDF Database>

=head1 DESCRIPTION

The options are:

=over 4

=item -h(elp)

Detailed help

=item -database

The prefix name of a XDF formatted sequence database containing the
genomic sequence to use when building repeat models.  The database
may be created with the WUBlast "xdformat" utility or with
the RepeatModeler wrapper script "BuildXDFDatabase".

=item -engine <abblast|wublast|ncbi>

The name of the search engine we are using.  I.e abblast/wublast or
ncbi (rmblast version).

=back

=head1 SEE ALSO

=over 4

RepeatMasker, WUBlast

=back

=head1 COPYRIGHT

 Copyright 2005-2010 Institute for Systems Biology

=head1 AUTHOR

 Robert Hubley <rhubley@systemsbiology.org>
 Arian Smit <asmit@systemsbiology.org>

=cut

#
# Module Dependence
#
use strict;
use FindBin;
use lib $FindBin::RealBin;
use Getopt::Long;
use POSIX qw(:sys_wait_h ceil floor);
use File::Copy;
use File::Spec;
use File::Path;
use File::Basename;
use Cwd;
use Data::Dumper;

# RepeatModeler Libraries
use RepModelConfig;
use lib $RepModelConfig::REPEATMASKER_DIR;
use RepeatUtil;

# RepeatMasker Libraries
use SearchResult;
use SearchResultCollection;
use WUBlastSearchEngine;
use NCBIBlastSearchEngine;
use SeqDBI;
use SimpleBatcher;
use FastaDB;

#
# Global Class Variables/Constants
#
my $CLASS = "RepeatModeler";
my $DEBUG = 0;
$DEBUG = 1 if ( $RepModelConfig::DEBUGALL == 1 );
$|     = 1;                                         # Turn autoflush on

#
# Version
#
#  This is a neat trick.  CVS allows you to tag
#  files in a repository ( i.e. cvs tag "2003/12/03" ).
#  If you check out that release into a new
#  directory with "cvs co -r "2003/12/03" it will
#  place this string into the $Name: open-1-0-5 $ space below
#  automatically.  This will help us keep track
#  of which release we are using.  If we simply
#  check out the code as "cvs co RepeatModeler" the
#  $Name: open-1-0-5 $ macro will be blank and thus we use
#  this as the development version.
#
my $CVSTag = '$Name: open-1-0-5 $';
my $version;
if ( $CVSTag =~ /\$\s*Name:\s*open-(\S+)\s*\$/ ) {
  $version = $1;
  $version =~ s/-/./g;
  $version = "open-$version";
}
else {
  $version =
      'development-$Id: RepeatModeler,v 1.57 2011/06/06 18:56:11 rhubley Exp $';
}

if ( $ARGV[ 0 ] && $ARGV[ 0 ] eq '-v' ) {
  print "RepeatModeler version $version\n";
  exit;
}

#
# Option processing
#  e.g.
#   -t: Single letter binary option
#   -t=s: String parameters
#   -t=i: Number paramters
#
my @opts = qw( help dir=s database=s engine=s );

#
# Get the supplied command line options, and set flags
#
my %options = ();
unless ( &GetOptions( \%options, @opts ) ) {
  exec "pod2text $0";
  exit( 1 );
}

# Print the internal POD documentation if something is missing
if ( !defined $options{'database'} || $options{'help'} ) {
  print "No database indicated\n\n";

  # This is a nifty trick so we don't have to have
  # a duplicate "USAGE()" subroutine.  Instead we
  # just recycle our POD docs.  See PERL POD for more
  # details.
  exec "pod2text $0";
  die;
}

#
# Setup the search engines
#
my $searchEngineN;
my $engine = $RepModelConfig::DEFAULT_SEARCH_ENGINE;
$engine = $options{'engine'} if ( $options{'engine'} );
if ( $engine ) {
  if ( $engine =~ /wublast|abblast/i ) {
    $engine        = "abblast";
    $searchEngineN =
        WUBlastSearchEngine->new(
                               pathToEngine => $RepModelConfig::WUBLASTN_PRGM );
    if ( not defined $searchEngineN ) {
      die "Cannot execute $RepModelConfig::WUBLASTN_PRGM please make "
          . "sure you have setup RepeatModeler to use AB/WUBlast "
          . "by running the configure script.\n";
    }
  }
  elsif ( $engine =~ /ncbi/i ) {
    $engine        = "ncbi";
    $searchEngineN =
        NCBIBlastSearchEngine->new(
                               pathToEngine => $RepModelConfig::RMBLASTN_PRGM );
    if ( not defined $searchEngineN ) {
      die "Cannot execute $RepModelConfig::RMBLASTN_PRGM please make "
          . "sure you have setup RepeatModeler to use NCBI (RMBlast) by "
          . "running the configure script.\n";
    }
  }
  else {
    print "I don't recognize the search engine type:  $engine\n";
    exec "pod2text $0";
    die;
  }
}

##
## MAGIC NUMBERS
##
#my $rsSampleSize               = 100000;     # The size of the sequence given
my $rsSampleSize               = 40000000;     # The size of the sequence given
                                               #   to RepeatScout. ( round #1 )
my $fragmentSize               = 40000;        # The size of the batches for
                                               #   all-vs-other search.
my $genomeSampleSizeStart      = 3000000;      # The initial sample size for
                                               #   RECON analysis
my $genomeSampleSizeMax        = 100000000;    # The max sample size for
                                               #   RECON analysis
my $genomeSampleSizeMultiplier = 3;            # The multiplier for sample size
                                               #   between rounds

# The normal RECON/RS family size minimum for which
#   we are interested in building models for.
my $recommendedFamilySize = 15;

# The absolute minimum RECON/RS family size for which
#   we will build a model.  Only invoked if there
#   are only small families returned by RECON/RS.
#   TODO: Perhaps this should only be invoked if
#         the genome is extremely small.
my $minFamilySize = 4;

#
# Gather details from the database
#
my $genomeDB = $options{'database'};
my $dbIndex;
if ( $engine eq "abblast" ) {
  $genomeDB =~ s/(.+)\.xn[idst]/$1/;
  if (    !-s "$genomeDB.xni"
       && !-s "$genomeDB.xnd"
       && !-s "$genomeDB.xns"
       && !-s "$genomeDB.xnt" )
  {
    die "Missing $genomeDB.xn[idst] files!\n";
  }
  $dbIndex = `$RepModelConfig::XDFORMAT_PRGM -m2 -n -r $genomeDB`;
}
else {
  $genomeDB =~ s/(.+)\.n[nihs][rndiq]/$1/;
  if (    !-s "$genomeDB.nhr"
       && !-s "$genomeDB.nin"
       && !-s "$genomeDB.nnd"
       && !-s "$genomeDB.nni"
       && !-s "$genomeDB.nsq" )
  {
    die "Missing $genomeDB.nhr, .nin, .nnd, .nni, .nsq files!\n";
  }
  $dbIndex =
`$RepModelConfig::NCBIDBCMD_PRGM -db $genomeDB -entry all -outfmt "%t %l"`;
}

#
# Print greeting
#
print "RepeatModeler Version $version\n";
print "================================\n";
print "Search Engine = $engine\n";
print "Database = $genomeDB ";

my %dbSeqs;    # Hash containing the names of all the DB seq IDs and their size
my @dbSeqIDArray = ();
my $dbSize       = 0;
while ( $dbIndex =~ />?(\S+)\s+(\d+)\s*$/mg ) {
  print "." if ( ( $#dbSeqIDArray % 10000 ) == 0 );
  $dbSeqs{$1} = $2;
  push @dbSeqIDArray, $1;
  $dbSize += $2;
}
undef $dbIndex;
print "\n";
die "Database $genomeDB does not contain any sequences!\n"
    if ( keys( %dbSeqs ) == 0 );
print "  - Sequences = " . ( $#dbSeqIDArray + 1 ) . "\n";
print "  - Bases = $dbSize\n";

my $dbSourceList = &initializeSampleSourceList(
                                               approxBlockSize => $fragmentSize,
                                               seqHash         => \%dbSeqs,
                                               dbSize          => $dbSize
);

#
# Randomize List
#
&fisherYatesShuffle( $dbSourceList );

#
# Create temp directory
#
my @tmpDirPath =
    ( cwd(), ( File::Spec->splitpath( $options{'database'} ) )[ 1 ] );

my $tmpDir;
if ( -d $options{'dir'} ) {
  $tmpDir = $options{'dir'};
}
else {
  $tmpDir = createTempDir( \@tmpDirPath );
}
print "Using temporary directory = $tmpDir\n";

my @dbUsedBlocks = ();
my $round        = 1;
my $totSampledBP = 0;
my $families;
my $numModels;
my $sampleSize = $genomeSampleSizeStart;
my %TimeBefore = ();

#
# Main loop
#
#    Sample from the sequence database starting from $genomeSampleSizeStart
#  and increasing by a factor of $genomeSampleSizeMultiplier until either
#  the sequence database is fully covered or we complete one round with
#  the sample size at $genomeSampleSizeMax
#
elapsedTime( "runtime" );    # Setup the timers
while ( $totSampledBP < $dbSize
        && ( $dbSize - $totSampledBP ) > $fragmentSize )
{

  # Reset the timers
  elapsedTime( 1 );
  elapsedTime( 2 );

  my $seqRemaining = ( $dbSize - ( $totSampledBP + $sampleSize ) );

  print "\n\nRepeatModeler Round # $round\n";
  print "========================\n";
  print "Searching for Repeats\n";
  print " -- Sampling from the database...\n";

  if ( $round > 1 ) {
    print "   - Gathering up to $sampleSize bp\n";
    if ( $seqRemaining > 0 && $seqRemaining <= $sampleSize ) {
      print "   - Increasing sample size to include end piece now = ";
      $sampleSize += $seqRemaining;
      print "$sampleSize\n";
    }
  }

  my $familyCutoff = $recommendedFamilySize;
  if ( ( $totSampledBP >= $dbSize || $sampleSize >= $genomeSampleSizeMax )
       && $numModels == 0 )
  {
    $familyCutoff = $minFamilySize;
  }

  # Setup file locations
  my $roundTmpDir       = "$tmpDir/round-$round";
  my $instFile          = "$tmpDir/instdb.txt";
  my $sampleFastaFile   = "$roundTmpDir/sampleDB-$round.fa";
  my $consensiFile      = "$tmpDir/consensi.fa";
  my $roundConsensiFile = "$roundTmpDir/consensi.fa";
  mkdir( $roundTmpDir );

  # Sample from the input database
  if ( $round == 1 ) {
    print "   - Gathering up to $rsSampleSize bp\n";
    &sampleFromDB(
                   sampleSizeMax  => $rsSampleSize,
                   dbUsedBlocks   => \@dbUsedBlocks,
                   dbSourceBlocks => $dbSourceList,
                   dbType         => $engine,
                   dbFile         => $genomeDB,
                   round          => $round,
                   fastaFile      => $sampleFastaFile,
                   prohibitX      => 1
    );
    push @{$dbSourceList}, @dbUsedBlocks;
    @dbUsedBlocks = ();
  }
  else {
    &sampleFromDB(
                   sampleSizeMax  => $sampleSize,
                   dbUsedBlocks   => \@dbUsedBlocks,
                   dbSourceBlocks => $dbSourceList,
                   dbType         => $engine,
                   dbFile         => $genomeDB,
                   round          => $round,
                   fastaFile      => $sampleFastaFile
    );
  }

  # Tabulate non-Ambiguous bases
  # TODO: Make this more efficient by tabulating in the sampleFromDB routine
  my $sampleDB = FastaDB->new( fileName => $sampleFastaFile,
                               openMode => SeqDBI::ReadOnly );
  my $actualGenomeSampleSize = 0;
  my $preMaskNonAmbigBases   = 0;
  my %sampleContigs          = ();
  foreach my $seqID ( $sampleDB->getIDs() ) {

    #my $tmpName = $seqID;
    my $tmpName = $sampleDB->getDescription( $seqID );
    $tmpName = $1 if ( $tmpName =~ /(\S+)_\d+-\d+/ );
    $sampleContigs{$tmpName}++;
    $preMaskNonAmbigBases   += $sampleDB->getSubtLength( $seqID );
    $actualGenomeSampleSize += $sampleDB->getSeqLength( $seqID );
  }
  undef $sampleDB;

  if ( $round == 1 ) {
    print "   - Final Sample Size = $actualGenomeSampleSize "
        . "bp ( $preMaskNonAmbigBases non ambiguous )\n";
    print "   - Num Contigs Represented = "
        . scalar( keys( %sampleContigs ) ) . "\n";
    print " -- Running RepeatScout on the sequences...\n";
    &runRepeatScout(
                     workDir    => $roundTmpDir,
                     rscoutPath => $RepModelConfig::RSCOUT_DIR,
                     trfPrgm    => $RepModelConfig::TRF_PRGM,
                     nsegPath   => "$RepModelConfig::WUBLAST_DIR/filter",
                     fastaFile  => $sampleFastaFile,
                     seqSize    => $actualGenomeSampleSize
    );

    if ( -s "$sampleFastaFile.rscons.filtered" ) {
      system( "cp $sampleFastaFile.rscons.filtered $roundConsensiFile" );

      if ( $engine eq "abblast" ) {

        # XDFORMAT the database
        system(   "$RepModelConfig::XDFORMAT_PRGM -n -I "
                . "$sampleFastaFile >> "
                . "$roundTmpDir/xdformat.log 2>&1" );
      }
      else {

        # MAKEBLASTDB the database
        system(   "$RepModelConfig::NCBIBLASTDB_PRGM -out $sampleFastaFile "
                . "-parse_seqids -dbtype nucl -in $sampleFastaFile >> "
                . "$roundTmpDir/makeblastdb.log 2>&1" );
      }

      ( $families, $numModels ) = &buildRSConsensi(
                                  workDir      => $roundTmpDir,
                                  consensiFile => $consensiFile,
                                  round        => $round,
                                  familyCutoff => $familyCutoff,
                                  engine       => $engine,
                                  numContigs => scalar( keys( %sampleContigs ) )
      );
    }
    else {
      system( "touch $sampleFastaFile.rscons.filtered" );
      print "NOTE: RepeatScout did not return any models.\n";
    }
    $round++;
    next;
  }

  # TRF sample
  print " -- Running TRFMask on the sequence...\n";

  system( "$RepModelConfig::REPEATMODELER_DIR/TRFMask $sampleFastaFile" );
  if ( -s "$sampleFastaFile.masked" ) {
    system( "rm $sampleFastaFile" );
    system( "mv $sampleFastaFile.masked $sampleFastaFile" );
  }

  # Mask repeats from previous round*s*
  if ( $round > 1 && -s $consensiFile ) {

    print " -- Masking repeats from the previous rounds...\n";

    $searchEngineN->setMinScore( 250 );
    $searchEngineN->setGenerateAlignments( 0 );
    $searchEngineN->setGapInit( -25 );
    $searchEngineN->setBandwidth( 10 );    # Changes gapW=31
    $searchEngineN->setInsGapExt( -5 );
    $searchEngineN->setDelGapExt( -5 );
    $searchEngineN->setMinMatch( 7 );
    $searchEngineN->setScoreMode( SearchEngineI::complexityAdjustedScoreMode );
    $searchEngineN->setAdditionalParameters( undef );
    $searchEngineN->setMaskLevel( undef );

    if ( $engine eq "abblast" ) {
      $searchEngineN->setMatrix(
"$RepModelConfig::REPEATMODELER_MATRICES_DIR/wublast/nt/comparison.matrix" );
      RepeatUtil::wublastMaskDatabase(
                                 xdformatPath => $RepModelConfig::XDFORMAT_PRGM,
                                 fastaFile    => $sampleFastaFile,
                                 consensi     => $consensiFile,
                                 searchEngine => $searchEngineN
      );
    }
    else {
      $searchEngineN->setMatrix(
         "$RepModelConfig::REPEATMODELER_MATRICES_DIR/ncbi/nt/comparison.matrix"
      );
      RepeatUtil::ncbiMaskDatabase(
                                makeDBPath => $RepModelConfig::NCBIBLASTDB_PRGM,
                                dbCMDPath  => $RepModelConfig::NCBIDBCMD_PRGM,
                                aliasPath  => $RepModelConfig::NCBIDBALIAS_PRGM,
                                workingDir => $roundTmpDir,
                                fastaFile  => $sampleFastaFile,
                                consensi   => $consensiFile,
                                searchEngine => $searchEngineN
      );
    }

    if ( -s "$sampleFastaFile.masked" ) {
      system( "mv $sampleFastaFile $sampleFastaFile.orig" );
      system( "mv $sampleFastaFile.masked $sampleFastaFile" );
    }

    ## TODO: Use the *.out file of the second to last round to
    ##       gather stats on contig coverage.  Then use the
    ##       RECON processing routine to gather the last round's
    ##       contig coverage.

  }

  # Tabulate non-Ambiguous bases
  my $sampleDB = FastaDB->new( fileName => $sampleFastaFile,
                               openMode => SeqDBI::ReadOnly );
  my $postMaskNonAmbigBases = 0;
  foreach my $seqID ( $sampleDB->getIDs() ) {
    $postMaskNonAmbigBases += $sampleDB->getSubtLength( $seqID );
  }
  undef $sampleDB;

  print " -- Sample Stats:\n";
  print "       Sample Size $actualGenomeSampleSize bp\n";
  print "       Num Contigs Represented = "
      . scalar( keys( %sampleContigs ) ) . "\n";
  print "       Non ambigous bp:\n";
  print "             Initial: $preMaskNonAmbigBases bp\n";
  print "             After Masking: $postMaskNonAmbigBases bp\n";
  if ( $preMaskNonAmbigBases > 0 ) {
    print "             Masked: "
        . sprintf(
                   "%0.2f",
                   (
                     100 - (
                        ( $postMaskNonAmbigBases * 100 ) / $preMaskNonAmbigBases
                     )
                   )
        )
        . " % \n";
  }
  else {
    print "             Masked: 0\n";
  }

  if ( $engine eq "abblast" ) {

    # XDFORMAT the database
    system(   "$RepModelConfig::XDFORMAT_PRGM -n -I $sampleFastaFile >> "
            . "$roundTmpDir/xdformat.log 2>&1" );
  }
  else {

    # MAKEBLASTDB the database
    system(   "$RepModelConfig::NCBIBLASTDB_PRGM -out $sampleFastaFile "
            . "-parse_seqids -dbtype nucl -in $sampleFastaFile >> "
            . "$roundTmpDir/makeblastdb.log 2>&1" );
  }

  # Gather details of the sample
  # TODO: Get this from the sample routine
  my %sampleSeqs;
  my @sampleSeqIDArray = ();
  my $sampleDBSize     = 0;
  my $sampleDBLen      = 0;
  my $sampleIndex;
  if ( $engine eq "abblast" ) {
    $sampleIndex = `$RepModelConfig::XDFORMAT_PRGM -m2 -n -r $sampleFastaFile`;
  }
  else {
    $sampleIndex =
`$RepModelConfig::NCBIDBCMD_PRGM -db $sampleFastaFile -entry all -outfmt "gi|%g %l"`;
  }
  while ( $sampleIndex =~ /(\S+)\s+(\d+)\s*$/mg ) {
    $sampleSeqs{$1} = $2;
    push @sampleSeqIDArray, $1;
    $sampleDBLen += $2;
    $sampleDBSize++;
  }
  undef $sampleIndex;
  $totSampledBP += $sampleDBLen;
  print " -- Input Database Coverage: $totSampledBP bp out of $dbSize bp ( "
      . sprintf( "%0.2f", ( $totSampledBP / $dbSize ) * 100 )
      . " % )\n";
  print "Sampling Time: " . elapsedTime( 2 ) . "\n";

  #
  # Run all-by-other combinations
  #
  if ( $engine eq "abblast" ) {
    $searchEngineN->setMatrix(
                          "$RepModelConfig::REPEATMODELER_MATRICES_DIR/wublast/"
                              . "nt/comparison.matrix" );
  }
  else {
    $searchEngineN->setMatrix(
                             "$RepModelConfig::REPEATMODELER_MATRICES_DIR/ncbi/"
                                 . "nt/comparison.matrix" );
  }
  $searchEngineN->setTempDir( "$roundTmpDir" );
  $searchEngineN->setMinScore( 250 );
  $searchEngineN->setGenerateAlignments( 0 );
  $searchEngineN->setGapInit( -25 );
  $searchEngineN->setInsGapExt( -5 );
  $searchEngineN->setDelGapExt( -5 );
  $searchEngineN->setMinMatch( 7 );
  $searchEngineN->setScoreMode( SearchEngineI::complexityAdjustedScoreMode );

  my $numHSPs = 0;    # Number of High Scoring Pairs produced
  unless ( -f "$roundTmpDir/msps.out" ) {
    open OUT, ">$roundTmpDir/msps.out";

    print "Running all-by-other comparisons...\n";
    my $totalComparisons =
        ( ( $sampleDBSize * $sampleDBSize ) - $sampleDBSize ) / 2;
    my $completedComparisons = 0;

    my $startSample   = 0;      # The ID of the start of the sample range
    my $endSample     = -1;     # The ID of the end of the sample range
    my $batchSize     = 0;      # The size of the batch in bp
    my $batchNum      = 1;      # Batch number we are working on
    my $compStartTime = time;
    while ( $startSample < $#sampleSeqIDArray ) {

      if ( $sampleSeqs{ $sampleSeqIDArray[ $startSample ] } <
           ( $fragmentSize / 4 ) )
      {

        do {
          $endSample++;
          if ( $engine eq "abblast" ) {
            system(   "$RepModelConfig::XDGET_PRGM -n $sampleFastaFile "
                    . "\"$sampleSeqIDArray[ $endSample ]\""
                    . " >> $roundTmpDir/batch-$batchNum.fa "
                    . "2>>$roundTmpDir/xdget.log" );
          }
          else {
            system(   "$RepModelConfig::NCBIDBCMD_PRGM -db $sampleFastaFile "
                    . "-entry \"$sampleSeqIDArray[ $endSample ]\" "
                    . ">> $roundTmpDir/batch-$batchNum.fa "
                    . "2>>$roundTmpDir/blastdbcmd.log" );
          }
          $batchSize += $sampleSeqs{ $sampleSeqIDArray[ $endSample ] };
            } while (    $endSample < $#sampleSeqIDArray
                      && $batchSize < $fragmentSize );

      }
      else {
        $endSample = $startSample;
        $batchSize = $sampleSeqs{ $sampleSeqIDArray[ $endSample ] };
        if ( $engine eq "abblast" ) {
          system(   "$RepModelConfig::XDGET_PRGM -n $sampleFastaFile "
                  . "\"$sampleSeqIDArray[ $endSample ]\""
                  . " >> $roundTmpDir/batch-$batchNum.fa "
                  . "2>>$roundTmpDir/xdget.log" );
        }
        else {
          system(   "$RepModelConfig::NCBIDBCMD_PRGM -db $sampleFastaFile "
                  . "-entry \"$sampleSeqIDArray[ $endSample ]\" "
                  . ">> $roundTmpDir/batch-$batchNum.fa "
                  . "2>>$roundTmpDir/blastdbcmd.log" );
        }
      }

      if ( $startSample == $endSample ) {
        print "  - Comparing batch-("
            . ( $startSample + 1 )
            . " of $sampleDBSize) to database: ";
      }
      else {
        print "  - Comparing batch-("
            . ( $startSample + 1 ) . "-"
            . ( $endSample + 1 )
            . " of $sampleDBSize) to database: ";
      }

      $searchEngineN->setQuery( "$roundTmpDir/batch-$batchNum.fa" );
      $searchEngineN->setSubject( $sampleFastaFile );

      if ( $engine eq "ncbi" ) {

        # Create a gilist
        my @giList = ( ( $startSample + 2 ) .. $sampleDBSize );
        open GI, ">$roundTmpDir/batch-$batchNum-gilist.txt"
            or die
            "Could not open up file $roundTmpDir/batch-$batchNum-gilist.txt "
            . "for writing!\n";
        print GI join( "\n", @giList ) . "\n";
        close GI;
        system(   "$RepModelConfig::NCBIDBALIAS_PRGM -gi_file_in "
                . "$roundTmpDir/batch-$batchNum-gilist.txt "
                . "-gi_file_out $roundTmpDir/batch-$batchNum-gilist "
                . "2>&1 > /dev/null " );
        $searchEngineN->setAdditionalParameters(
                              " -gilist $roundTmpDir/batch-$batchNum-gilist " );
      }
      else {
        $searchEngineN->setAdditionalParameters( "dbslice="
                                    . ( $startSample + 2 )
                                    . "-$sampleDBSize/$sampleDBSize -gapW=32" );
      }

      my ( $status, $resultCollection ) = $searchEngineN->search();
      if ( $status ) {
        print STDERR "\nERROR from search engine (", $? >> 8, ") \n";
      }
      else {

        print "Filtering ( " . $resultCollection->size() . " ) Results...\n"
            if ( $DEBUG );

        for ( my $k = 0 ; $k < $resultCollection->size() ; $k++ ) {
          my $resultRef = $resultCollection->get( $k );
          my $qryId     = $resultRef->getQueryName();
          $qryId = $1 if ( $qryId =~ /^gi\|(\d+).*/ );
          my $sbjId = $resultRef->getSubjName();
          $sbjId = $1 if ( $sbjId =~ /^gi\|(\d+).*/ );
          next if ( $sbjId <= $qryId );
          my $mspLine = "";
          $mspLine = sprintf( "%06d %04.1f ",
                              $resultRef->getScore(),
                              ( 100 - $resultRef->getPctDiverge() ) );

          if ( $resultRef->getOrientation ne "C" ) {
            $mspLine .= sprintf( "%06d %06d ",
                                 $resultRef->getQueryStart(),
                                 $resultRef->getQueryEnd() );
          }
          else {
            $mspLine .= sprintf( "%06d %06d ",
                                 $resultRef->getQueryEnd(),
                                 $resultRef->getQueryStart() );
          }
          $mspLine .= sprintf( "%s %06d %06d %s \n",
                               "gi|$qryId",
                               $resultRef->getSubjStart(),
                               $resultRef->getSubjEnd(), "gi|$sbjId" );
          print OUT $mspLine;
          $numHSPs++;
        }

      }

      $completedComparisons =
          ( ( ( $endSample * $endSample ) - $endSample ) / 2 ) +
          ( ( $sampleDBSize - $endSample ) * $endSample );
      my $comparisonsLeft   = $totalComparisons - $completedComparisons;
      my $estimatedTimeLeft = "--";
      if ( ( time - $compStartTime ) > 0 && $completedComparisons > 0 ) {
        $estimatedTimeLeft =
            int( $comparisonsLeft /
                 ( $completedComparisons / ( time - $compStartTime ) ) );
        my $Min = int( $estimatedTimeLeft / 60 );
        $estimatedTimeLeft -= $Min * 60;
        my $Hours = int( $Min / 60 );
        $Min -= $Hours * 60;
        my $Sec = $estimatedTimeLeft;
        $estimatedTimeLeft = "$Hours:$Min:$Sec";
      }

      print "\n          "
          . sprintf( "%0.0f",
                     ( $completedComparisons / $totalComparisons ) * 100 )
          . "% completed, "
          . " $estimatedTimeLeft (hh:mm:ss) est. time remaining.\n";

      $startSample = $endSample + 1;
      $batchNum++;
    }
    close OUT;
    print "Comparison Time: "
        . elapsedTime( 2 )
        . ", $numHSPs HSPs Collected\n";
  }

  ## Bugfix reported by Nathaniel Street.
  if ( $numHSPs > $recommendedFamilySize ) {

    # Create the seqnames file
    unless ( -f "$roundTmpDir/seqnames" ) {
      open OUT, ">$roundTmpDir/seqnames";
      print OUT "" . scalar( @sampleSeqIDArray ) . "\n";
      foreach my $key ( sort( @sampleSeqIDArray ) ) {
        print OUT "$key\n";
      }
      close OUT;
    }

    # Run recon
    unless ( -f "$roundTmpDir/summary/eles" ) {
      runRECON( workDir   => $roundTmpDir,
                reconPath => $RepModelConfig::RECON_DIR );
    }

    #
    #  Build consensi
    #
    if ( -f "$roundTmpDir/summary/eles" ) {
      my $tmpNumModels = 0;
      ( $families, $tmpNumModels ) = &buildReconConsensi(
                                                  workDir      => $roundTmpDir,
                                                  consensiFile => $consensiFile,
                                                  round        => $round,
                                                  familyCutoff => $familyCutoff
      );
      $numModels += $tmpNumModels;
    }
    else {
      print "\n  - Recon did not produce any element definitions.\n\n";
    }
  }

  $round++;

  # Remove all the old batch files
  opendir( DIR, $roundTmpDir )
      or die $CLASS . ": Can't open director $roundTmpDir " . "for reading!\n";
  my $file;
  while ( defined( $file = readdir( DIR ) ) ) {
    if ( $file =~ /batch-(\d+).fa/ ) {
      print "Unlinking old batch $roundTmpDir/$file\n" if ( $DEBUG );
      unlink( "$roundTmpDir/$file" );
    }
  }
  closedir( DIR );

  print "Round Time: " . elapsedTime( 1 ) . "\n";

  if ( $sampleSize < $genomeSampleSizeMax ) {
    $sampleSize *= $genomeSampleSizeMultiplier;
    $sampleSize = $genomeSampleSizeMax
        if ( $sampleSize > $genomeSampleSizeMax );
  }
  else {

    # We are done
    last;
  }
}    # Main Loop while(...

print "\nDiscovery complete: $numModels families found\n";

## TODO: Add code to serially mask the last largest
##       sample one more time and collect the segregation
##       data.

## TODO: This is where we run postprocessing modules
##
##    - Edge extension
##    - Family Merging
##    - Classification
elapsedTime( 1 );
if ( $numModels > 0 ) {
  print "Classifying Repeats...\n";
  system(   "$RepModelConfig::REPEATMODELER_DIR/RepeatClassifier "
          . "-consensi $tmpDir/consensi.fa" );
  print "Classification Time: " . elapsedTime( 1 ) . "\n";
}

print "Program Time: " . elapsedTime( "runtime" ) . "\n";

## TODO: Tidy up and remove tmp directory unless we are instructed not
##       to.
if ( $numModels > 0 ) {
  print "Done....look for your results in:\n  "
      . "$tmpDir ( consensi.fa.classified )\n";
}
exit;

#############################################################################
#                          S U B R O U T I N E S                            #
#############################################################################

sub runRECON {
  my %parameters = @_;

  elapsedTime( 2 );
  die $CLASS . "::runRecon() missing reconPath parameter!\n"
      if ( !defined $parameters{'reconPath'} );
  my $RECON_DIR = $parameters{'reconPath'};

  die $CLASS . "::runRecon() missing workDir parameter!\n"
      if ( !defined $parameters{'workDir'} );

  my $tmpDir  = $parameters{'workDir'};
  my $origDir = getcwd();
  chdir( $tmpDir );

  # If these two do not exist imagespread will fail
  # TODO: Make sure they aren't already here.
  system( "mkdir images" );
  system( "mkdir summary" );

  print "  - RECON: Running imagespread..\n";
  `$RECON_DIR/imagespread seqnames msps.out`;
  `mv gmon.out imagespread-gmon.out` if ( -f "gmon.out" );

  if ( $? ) { die "imagespread failed. Exit code $?\n"; }
  print "RECON Elapsed: " . elapsedTime( 2 ) . "\n";

  my $sect = 1;

  for ( my $i = 1 ; $i <= $sect ; $i++ ) {
    my $spread = "images/spread" . $i;
    `sort -k 3,3 -k 4n,4n -k 5nr,5nr $spread >> images/images_sorted`;
    if ( $? ) { die "sort failed for $spread.\n"; }
  }

  `rm -f images/spread*`;

  # initial definition of elements
  `rm -rf ele_def_res`;
  `mkdir ele_def_res`;

  print "  - RECON: Running initial definition of elements ( eledef )..\n";
  `$RECON_DIR/eledef seqnames msps.out single`;
  `mv gmon.out eledef-gmon.out` if ( -f "gmon.out" );
  if ( $? ) { die "eledef failed. Exit code $?\n"; }
  print "RECON Elapsed: " . elapsedTime( 2 ) . "\n";

  # re-defining elements
  `rm -rf ele_redef_res`;
  `mkdir ele_redef_res`;

  `rm -f tmp tmp2`;
  `ln -s ele_def_res tmp`;
  `ln -s ele_redef_res tmp2`;

  print "  - RECON: Running re-definition of elements ( eleredef )..\n";
  `$RECON_DIR/eleredef seqnames`;
  `mv gmon.out eleredef-gmon.out` if ( -f "gmon.out" );
  if ( $? ) { die "eleredef failed. Exit code $?\n"; }
  print "RECON Elapsed: " . elapsedTime( 2 ) . "\n";

  `rm -f tmp tmp2`;

  # re-defining edges
  `rm -rf edge_redef_res`;
  `mkdir edge_redef_res`;

  `rm -f tmp tmp2`;
  `ln -s ele_redef_res tmp`;
  `ln -s edge_redef_res tmp2`;

  print "  - RECON: Running re-definition of edges ( edgeredef )..\n";
  `$RECON_DIR/edgeredef seqnames`;
  `mv gmon.out edgeredef-gmon.out` if ( -f "gmon.out" );
  if ( $? ) { die "edgeredef failed. Exit code $?\n"; }
  print "RECON Elapsed: " . elapsedTime( 2 ) . "\n";

  # famdef
  `rm -f tmp tmp2`;
  `ln -s edge_redef_res tmp`;

  print "  - RECON: Running family definition ( famdef )..\n";
  `$RECON_DIR/famdef seqnames`;
  `mv gmon.out famdef-gmon.out` if ( -f "gmon.out" );
  if ( $? ) { die "famdef failed. Exit code $?\n"; }
  print "RECON Elapsed: " . elapsedTime( 2 ) . "\n";

  `rm -f tmp`;

  chdir( $origDir );

  return;
}

##-------------------------------------------------------------------------##
#
# Use: my = runRepeatScout( .. );
#
#
##-------------------------------------------------------------------------##
sub runRepeatScout {
  my %parameters = @_;
  die $CLASS . "::runRepeatScout() missing rscoutPath parameter!\n"
      if ( !defined $parameters{'rscoutPath'} );
  my $RSCOUT_DIR = $parameters{'rscoutPath'};

  die $CLASS . "::runRepeatScout() missing trfPrgm parameter!\n"
      if ( !defined $parameters{'trfPrgm'} );
  my $TRF_PRGM = $parameters{'trfPrgm'};

  die $CLASS . "::runRepeatScout() missing nsegPath parameter!\n"
      if ( !defined $parameters{'nsegPath'} );
  my $NSEG_DIR = $parameters{'nsegPath'};

  die $CLASS . "::runRepeatScout() missing workDir parameter!\n"
      if ( !defined $parameters{'workDir'} );
  my $tmpDir = $parameters{'workDir'};

  die $CLASS . "::runRepeatScout() missing fastaFile parameter!\n"
      if ( !defined $parameters{'fastaFile'} );
  my $fastaFile = $parameters{'fastaFile'};

  die $CLASS . "::runRepeatScout() missing seqSize parameter!\n"
      if ( !defined $parameters{'seqSize'} );
  my $seqSize = $parameters{'seqSize'};

  my $origDir = getcwd();
  chdir( $tmpDir );

  # Calculate lmer size
  my $lmerSize = ceil( ( log( $seqSize ) / log( 4 ) ) + 1 );

  print "   - RepeatScout: Running build_lmer_table ( l = $lmerSize )..\n";
  my $cmd =
        "$RSCOUT_DIR/build_lmer_table -l $lmerSize -sequence "
      . "$fastaFile -freq $fastaFile.lfreq";
  `$cmd`;
  if ( $? ) { die "build_lmer_table failed. Exit code $?\n"; }

  #
  # My lmer generator "elmer"
  #
  #print "   - RepeatScout: Running elmer ( l = $lmerSize )..\n";
  #$ENV{'TMPDIR'} = $tmpDir;
  #my $cmd =
  #      "/usr/local/bin/elmer -rscompat -lmersize $lmerSize -rscompat "
  #    . " -mincount 3 -tandemdist 500 -output $fastaFile.lfreq "
  #    . "$fastaFile > /dev/null 2>&1\n";
  #`$cmd`;
  #if ( $? ) { die "elmer failed. Exit code $?\n"; }
  #

  print "   - RepeatScout: Running RepeatScout..\n";
  $cmd =
        "$RSCOUT_DIR/RepeatScout -l $lmerSize -sequence $fastaFile"
      . " -tandemdist 500 -output $fastaFile.rscons -freq $fastaFile.lfreq "
      . "-stopafter 100";

  #print "Running cmd: $cmd\n";
  `$cmd`;
  if ( $? ) { die "RepeatScout failed. Exit code $?\n"; }

  # Run TRF/NSEG on sequences
  $ENV{'TRF_COMMAND'}  = $TRF_PRGM;
  $ENV{'NSEG_COMMAND'} = "$NSEG_DIR/nseg";
  $cmd                 =
        "$RSCOUT_DIR/filter-stage-1.prl $fastaFile.rscons > "
      . "$fastaFile.rscons.filtered 2>/dev/null";
  `$cmd`;

  chdir( $origDir );

  return;
}

##-------------------------------------------------------------------------##
#
# Use: my = buildRSConsensi( .. );
#
#   RepeatScout produces consensus sequences but does not indicate which
#   regions from the genome contributed to the overall multiple alignment.
#   To compensate for this we search the genome with the consensus and
#   obtain the complete set of matching regions.
#
##-------------------------------------------------------------------------##
sub buildRSConsensi {
  my %parameters = @_;

  die "buildRSConsensi(): Missing workDir parameter!\n"
      if ( !defined $parameters{'workDir'} );
  my $workDir = $parameters{'workDir'};

  die "buildRSConsensi(): Missing round parameter!\n"
      if ( !defined $parameters{'round'} );
  my $round = $parameters{'round'};

  die "buildRSConsensi(): Missing consensiFile parameter!\n"
      if ( !defined $parameters{'consensiFile'} );
  my $consensiFile = $parameters{'consensiFile'};

  die "buildRSConsensi(): Missing familyCutoff parameter!\n"
      if ( !defined $parameters{'familyCutoff'} );
  my $familySizeCutoff = $parameters{'familyCutoff'};

  die "buildRSConsensi(): Missing numContigs parameter!\n"
      if ( !defined $parameters{'numContigs'} );
  my $dbNumContigs = $parameters{'numContigs'};

  die "buildRSConsensi(): Missing engine parameter!\n"
      if ( !defined $parameters{'engine'} );
  my $engine = $parameters{'engine'};

  my %families            = ();
  my $numModels           = 0;
  my @indices             = ();
  my %localizedToSeqNames = ();

  ## Get Sequences
  print "   - Collecting repeat instances...\n";

  my $searchEngineN;
  if ( $engine eq "abblast" ) {
    $searchEngineN =
        WUBlastSearchEngine->new(
                               pathToEngine => $RepModelConfig::WUBLASTN_PRGM );
    $searchEngineN->setMatrix(
      "$RepModelConfig::REPEATMODELER_MATRICES_DIR/wublast/nt/comparison.matrix"
    );

    # TODO CONSIDER THIS!
    #$searchEngineN->setMaskLevel( 80 );
    #$searchEngineN->setMaskLevelSequence( SearchResult::SubjectStrand );
  }
  else {
    $searchEngineN =
        NCBIBlastSearchEngine->new(
                               pathToEngine => $RepModelConfig::RMBLASTN_PRGM );
    $searchEngineN->setMatrix(
      "$RepModelConfig::REPEATMODELER_MATRICES_DIR/ncbi/nt/comparison.matrix" );
  }

  $searchEngineN->setTempDir( "$workDir" );
  $searchEngineN->setMinScore( 250 );
  $searchEngineN->setGenerateAlignments( 1 );
  $searchEngineN->setGapInit( -25 );
  $searchEngineN->setInsGapExt( -5 );
  $searchEngineN->setDelGapExt( -5 );
  $searchEngineN->setMinMatch( 7 );
  $searchEngineN->setScoreMode( SearchEngineI::complexityAdjustedScoreMode );
  $searchEngineN->setSubject( "$workDir/sampleDB-$round.fa" );
  $searchEngineN->setQuery( "$workDir/consensi.fa" );
  ## TODO: Consider if we should define a setHSPMax parameter in
  ##       WUBlastSearchEngine.  This might save us some time when we
  ##       really only care about a small set of the highest scoring elements.
  ##       Careful though...as we don't want to miss the overall distribution
  ##       of elements and fool the segmental duplication filter.
  if ( $engine eq "abblast" ) {
    $searchEngineN->setOverrideParameters(
                      "$workDir/sampleDB-$round.fa $workDir/consensi.fa "
                    . "-warnings -kap -wordmask=dust wordmask=seg maskextra=10 "
                    . "-hspmax=20 V=0 B=250 Q=25 R=5 W=7 S=250 gapS2=250 "
                    . "S2=125 X=250 gapX=500 -matrix=comparison.matrix" );

    #print "WUBlastParams: " . $searchEngineN->getParameters() . "\n";
  }

  my ( $status, $resultCollection ) = $searchEngineN->search();
  if ( $status ) {
    print STDERR "\nERROR from search engine (", $? >> 8, ") \n";
  }
  else {
    elapsedTime( "family_refinement" );
    open OUTC, ">$workDir/consensi-refined.fa";
    open INDX, ">$workDir/index.html";
    print "Filtering Results...\n" if ( $DEBUG );
    for ( my $k = 0 ; $k < $resultCollection->size() ; $k++ ) {
      my $resultRef = $resultCollection->get( $k );

      # Extract the true seq name and keep track of how
      # many sequences this element is found -- used for
      # segmental duplication filtering.
      my $tmpName = $resultRef->getSubjName();
      $tmpName = $1 if ( $tmpName =~ /(\S+)_\d+-\d+/ );
      $localizedToSeqNames{$tmpName}++;

      my $desc = $resultRef->getSubjName();
      $desc = $1 if ( $desc =~ /gi\|\d+\s+(\S+)/ );

      # Set the new seqID
      my $seqID = "gi|"
          . ( $k + 1 ) . " "
          . $desc . "_"
          . $resultRef->getSubjStart() . "-"
          . $resultRef->getSubjEnd();
      my $sequence = $resultRef->getSubjString();
      $sequence =~ s/-//g;

      #if ( $resultRef->getOrientation() eq "C" ) {
      #  $sequence = reverse $sequence;
      #  $sequence =~ tr/ACGTYRMKHBVD/TGCARYKMDVBH/;    # complement
      #}
      push @{ $families{ $resultRef->getQueryName() }->{'elements'} },
          {
            'seqID' => $seqID,
            'seq'   => $sequence,
            'score' => $resultRef->getScore()
          };
    }
    undef $resultCollection;

    #print "families: " . Dumper( \%families ) . "\n";
    # Sort keys by most abundant family first
    my @sortedKeys = sort {
      $#{ $families{$b}->{'elements'} } <=> $#{ $families{$a}->{'elements'} }
    } keys( %families );

    my $doRefinement = 1;
    if ( $doRefinement ) {

      # Refine families
      my $familyID = 0;
      foreach my $key ( @sortedKeys ) {

        # Quit if remaining family sizes are below cutoff
        last if ( $#{ $families{$key}->{'elements'} } < $familySizeCutoff );

        $families{$key}->{'roundfam'} = $familyID;

        open FAM, ">$workDir/family-$familyID.fa"
            || die "RepeatModler: Can't open "
            . "output file family-$familyID.fa\n";

        #      # Sort elements in each family by longest first
        #      foreach my $ele ( sort { length( $b->{'seq'} ) <=>
        #                               length( $a->{'seq'} ) }
        #                             @{ $families{ $key }->{'elements'} } )
        #      {
        #        print FAM ">" . $ele->{'seqID'} . "\n";
        #        print FAM "" . $ele->{'seq'} . "\n";
        #      }

        # Sort elements in each family by highest scoring first
        my $numElements = 0;
        foreach my $ele ( sort { $b->{'score'} <=> $a->{'score'} }
                          @{ $families{$key}->{'elements'} } )
        {

          # Number of elements to keep
          last if ( $numElements == 100 );
          print FAM ">" . $ele->{'seqID'} . "\n";
          print FAM "" . $ele->{'seq'} . "\n";
          $numElements++;
        }
        close FAM;

        my $cons;
        my $maSize = 1;

        print " -- Refining Family $key / $familyID ( RS Elements: "
            . ( $#{ $families{$key}->{'elements'} } + 1 )
            . ", Using $numElements ):\n";

        # TODO: Make this local!
        system(   "$RepModelConfig::REPEATMODELER_DIR/Refiner -engine $engine "
                . "-noTmp $workDir/family-$familyID.fa" );

        open INREF, "<$workDir/family-$familyID.fa.refiner_cons"
            || die $CLASS
            . ": Could not open refined model $workDir/family-$familyID."
            . "fa.refiner_cons!\n";
        while ( <INREF> ) {
          if ( /Final Multiple Alignment Size = (\d+)/ ) {
            $maSize = $1;
          }
          else {
            $cons .= $_;
          }
        }
        close INREF;
        print "Refinement: " . elapsedTime( 2 ) . "\n";

        if ( $cons ne "" ) {

          # Save the consensus
          $families{$key}->{'consensus'}         = $cons;
          $families{$key}->{'finalElementCount'} = $maSize;

          # Save the consensus to the consensi file.
          print OUTC ">family-$familyID ( RepeatScout Family =  $key, "
              . " Size = "
              . ( $#{ $families{$key}->{'elements'} } + 1 )
              . ", Refiner Input Size = $numElements, Final Multiple Alignment"
              . " Size = "
              . $maSize . " )\n";
          print OUTC "$cons\n";

          my $indexStr =
                "<a href=\"family-$familyID-cons.html\">family-$familyID"
              . " ( RepeatScout Family $key, Size = "
              . ( $#{ $families{$key}->{'elements'} } + 1 )
              . ", Refiner Input Size = $numElements, "
              . " Final Multiple Alignment Size = "
              . $maSize
              . " )</a><br>\n";

          print INDX $indexStr;
          push @indices, [ $maSize, $indexStr ];

        }

        $familyID++;
      }
      close INDX;

      # sorted indices
      open INDX, ">$workDir/index.html";
      foreach my $index ( sort { $b->[ 0 ] <=> $a->[ 0 ] } @indices ) {
        print INDX $index->[ 1 ];
      }
      close INDX;
      close OUTC;
    }
    else    # if ( $doRefinement )
    {
      my $familyID = 0;
      my $consDB = FastaDB->new( fileName => "$workDir/consensi.fa",
                                 openMode => SeqDBI::ReadOnly );
      foreach my $key ( @sortedKeys ) {
        $families{$key}->{'roundfam'}          = $familyID;
        $families{$key}->{'consensus'}         = $consDB->getSequence( $key );
        $families{$key}->{'finalElementCount'} =
            $#{ $families{$key}->{'elements'} } + 1;
        $familyID++;
      }
      undef $consDB;
    }

    #
    # Write out final trimmed consensi.fa file
    #
    open OUTC, ">>$consensiFile";
    foreach my $familyKey (
      sort {
        $families{$b}{'finalElementCount'} <=> $families{$a}
            {'finalElementCount'}
      }
      keys( %families )
        )
    {
      last
          if (
             $families{$familyKey}->{'finalElementCount'} < $familySizeCutoff );
      print OUTC ">rnd-$round"
          . "_family-"
          . $families{$familyKey}->{'roundfam'}
          . " ( RepeatScout Family Size = "
          . ( $#{ $families{$familyKey}->{'elements'} } + 1 )
          . " Final Multiple Alignment Size (possibly truncated)  = "
          . $families{$familyKey}->{'finalElementCount'}
          . " Localized to "
          . scalar( keys( %localizedToSeqNames ) ) . " out " . "of "
          . $dbNumContigs
          . " contigs )\n";
      print OUTC "$families{ $familyKey }->{'consensus'}\n";
      $numModels++;

    }
    close OUTC;
    print "Family Refinement: " . elapsedTime( "family_refinement" ) . "\n";

  }
  undef $searchEngineN;
  return \%families, $numModels;

}

##-------------------------------------------------------------------------##
#
# Use: my = buildReconConsensi( .. );
#
#
##-------------------------------------------------------------------------##
sub buildReconConsensi {
  my %parameters = @_;

  die "buildReconConsensi(): Missing workDir parameter!\n"
      if ( !defined $parameters{'workDir'} );
  my $workDir = $parameters{'workDir'};

  die "buildReconConsensi(): Missing round parameter!\n"
      if ( !defined $parameters{'round'} );
  my $round = $parameters{'round'};

  die "buildReconConsensi(): Missing consensiFile parameter!\n"
      if ( !defined $parameters{'consensiFile'} );
  my $consensiFile = $parameters{'consensiFile'};

  die "buildReconConsensi(): Missing familyCutoff parameter!\n"
      if ( !defined $parameters{'familyCutoff'} );
  my $familySizeCutoff = $parameters{'familyCutoff'};

  ## Read in element definitions
  my %families = ();
  if ( -f "$workDir/summary/eles" ) {
    open IN, "<$workDir/summary/eles";
    while ( <IN> ) {
      next if ( /^#/ );
      if ( /\s+\d+\s+/ ) {
        my @fields = split;
        push @{ $families{ $fields[ 0 ] }->{'elements'} },
            {
              seqName   => $fields[ 3 ],
              elementID => $fields[ 1 ],
              orient    => $fields[ 2 ],
              start     => $fields[ 4 ],
              end       => $fields[ 5 ]
            };
      }
    }
    close IN;
  }
  else {
    die "Error: Recon failed to produce the summary/eles file!\n";
  }

  ## Get Sequences
  print "  - Obtaining element sequences\n";
  open OUTC, ">$workDir/consensi.fa";
  open INDX, ">$workDir/index.html";

  ### Locate the batch containing this elements sequence.
  my $batchName = "sampleDB-$round.fa";

  ## Open the sequence batch file.
  my $batchDB = FastaDB->new( fileName => "$workDir/$batchName",
                              openMode => SeqDBI::ReadOnly );

  my @indices = ();

  my @sortedKeys = sort {
    $#{ $families{$b}->{'elements'} } <=> $#{ $families{$a}->{'elements'} }
  } keys( %families );

 # Alter the minimum family size so that we
 #my $familySizeCutoff = $recommendedFamilySize;
 #if ( keys( %families ) > 10 ) {
 #  $familySizeCutoff = $#{ $families{ $sortedKeys[ 10 ] }->{'elements'} }
 #      if (
 #     $#{ $families{ $sortedKeys[ 10 ] }->{'elements'} } < $familySizeCutoff );
 #  $familySizeCutoff = $minFamilySize
 #      if ( $familySizeCutoff < $minFamilySize );
 #}
 #else {
 #  $familySizeCutoff = $minFamilySize;
 #}
  print "Number of families returned by RECON: "
      . scalar( keys( %families ) ) . "\n";
  print "Processing families with greater than $familySizeCutoff elements\n";
  elapsedTime( "family_refinement" );

  # Loop through all families starting with the ones
  # containing the most elements.
  foreach my $familyID ( @sortedKeys ) {
    last if ( $#{ $families{$familyID}->{'elements'} } < $familySizeCutoff );
    print "\nProcessing RECON family: $familyID\n";

    elapsedTime( 2 );
    ## Using the eles file and the sequence batch file
    ## create a new family-#.fa file containing the
    ## sequences for each elemement.
    my $elementsRef = $families{$familyID}->{'elements'};
    open FAM, ">$workDir/family-$familyID.fa"
        || die "RepeatModler: Can't open "
        . "output file family-$familyID.fa\n";

    my $numElements = 0;

    ## Loop through the elements for a given family starting
    ## first with the longest ones.
    print "  - Saving elements to a file...\n";
    my $giID = 1;
    foreach my $elementRef (
      sort {
        ( $b->{'end'} - $b->{'start'} ) <=> ( $a->{'end'} - $a->{'start'} )
      } @{$elementsRef}
        )
    {
      $numElements++;

      #
      # TODO: Rethink the syntax of this convention
      #
      # Parse genomic start/end out of batch seqname:
      #
      #   The RM convention is that a batch file is a fragment
      #   of a genomic (input sequence) sample.  The range of
      #   the fragment is placed in the sequence name.  The
      #   general form is SeqID_startPos-endPos.  So in order
      #   to place this sequence in it's genomic context we
      #   need to parse out these numbers.
      #
      my $seqName = $elementRef->{'seqName'};
      my $genomicStartPos;
      my $genomicEndPos;
      my $genomicSeqID;
      if ( $seqName =~ /(\S+)_(\d+)-(\d+)/ ) {
        $genomicSeqID    = $1;
        $genomicStartPos = $2;
        $genomicEndPos   = $3;
      }

      ## Get the sequence.
      my $startOffset = $elementRef->{'start'};
      my $endOffset   = $elementRef->{'end'};
      my $length      = $endOffset - $startOffset;
      my $sequence    = $batchDB->getSubstr( $seqName, $startOffset, $length );

      ## Determine if we need to reorient the sequence based
      ## on Recon's call of the orientation.
      if ( $elementRef->{'orient'} ne "1" ) {
        $sequence = reverse( $sequence );
        $sequence =~ tr/ACGTYRMKHBVD/TGCARYKMDVBH/;
        my $tmpOffset = $startOffset;
        $startOffset = $endOffset;
        $endOffset   = $tmpOffset;
      }

      ## Save the sequence
      $elementRef->{'sequence'} = $sequence;
      print FAM ">gi|$giID $genomicSeqID" . "_"
          . ( $startOffset + $genomicStartPos - 1 ) . "-"
          . ( $endOffset + $genomicStartPos - 1 )
          . " element-"
          . $elementRef->{'elementID'} . "\n";
      print FAM "" . $elementRef->{'sequence'} . "\n";
      $giID++;
    }
    close FAM;
    print "    - " . ( $#{$elementsRef} + 1 ) . " elements found.\n";
    print "Element Gathering: " . elapsedTime( 2 ) . "\n";

    # Check to see if we have at least two elements in this
    # family.  If so we can attempt to make a multiple alignment
    # based consensus.
    my $cons;
    my $maSize = 1;

    if ( @{$elementsRef} >= $familySizeCutoff ) {
      print "Refining family-$familyID model...\n";

      # TODO: Make this local!
      system(   "$RepModelConfig::REPEATMODELER_DIR/Refiner -engine $engine "
              . "-noTmp $workDir/family-$familyID.fa" );

      open INREF, "<$workDir/family-$familyID.fa.refiner_cons"
          || die $CLASS
          . ": Could not open refined model $workDir/family-$familyID."
          . "fa.refiner_cons!\n";
      while ( <INREF> ) {
        if ( /Final Multiple Alignment Size = (\d+)/ ) {
          $maSize = $1;
        }
        else {
          $cons .= $_;
        }
      }
      close INREF;
      print "Refinement: " . elapsedTime( 2 ) . "\n";

    }
    else {

      print "Family too small...moving on\n";

      # Only one element....strange that this makes it through
      # recon...wish we knew why.  Anyway...for the sake of
      # completeness we use the sequence itself as the consensus.
      #$cons = $families{$familyID}->{'elements'}->[ 0 ]->{'sequence'};

    }

    if ( $cons ne "" ) {

      # Save the consensus
      $families{$familyID}->{'consensus'}         = $cons;
      $families{$familyID}->{'finalElementCount'} = $maSize;

      # Save the consensus to the consensi file.
      print OUTC ">family-$familyID ( Recon Family Size = "
          . ( $#{ $families{$familyID}->{'elements'} } + 1 )
          . " Final Multiple Alignment Size = "
          . $maSize . " )\n";
      print OUTC "$cons\n";

      my $indexStr =
            "<a href=\"family-$familyID-cons.html\">family-$familyID"
          . " ( Recon Family Size = "
          . ( $#{ $families{$familyID}->{'elements'} } + 1 )
          . " Final Multiple Alignment Size = "
          . $maSize
          . " )</a><br>\n";

      print INDX $indexStr;
      push @indices, [ $maSize, $indexStr ];

    }

  }    # Foreach family
  undef $batchDB;
  close INDX;

  # sorted indices
  open INDX, ">$workDir/index.html";
  foreach my $index ( sort { $b->[ 0 ] <=> $a->[ 0 ] } @indices ) {
    print INDX $index->[ 1 ];
  }
  close INDX;
  close OUTC;

  #
  # Write out final trimmed consensi.fa file
  #
  my $numModels = 0;
  open OUTC, ">>$consensiFile";
  foreach my $familyKey (
    sort {
      $families{$b}{'finalElementCount'} <=> $families{$a}{'finalElementCount'}
    }
    keys( %families )
      )
  {

    last
        if ( $families{$familyKey}->{'finalElementCount'} < $familySizeCutoff );
    print OUTC ">rnd-$round"
        . "_family-$familyKey ( Recon Family Size = "
        . ( $#{ $families{$familyKey}->{'elements'} } + 1 )
        . " Final Multiple Alignment Size = "
        . $families{$familyKey}->{'finalElementCount'} . " )\n";
    print OUTC "$families{ $familyKey }->{'consensus'}\n";
    $numModels++;

  }
  close OUTC;
  print "Family Refinement: " . elapsedTime( "family_refinement" ) . "\n";

  return \%families, $numModels;

}

sub initializeSampleSourceList {
  my %parameters = @_;

  my $approxBlockSize = $parameters{'approxBlockSize'};
  my %dbSeqs          = %{ $parameters{'seqHash'} };
  my $dbSize          = $parameters{'dbSize'};

  my @sampleSourceList = ();
  foreach my $seqID ( keys( %dbSeqs ) ) {
    my $seqSize = $dbSeqs{$seqID};

    my $partialBlockSize =
        $seqSize - ( int( $seqSize / $approxBlockSize ) * $approxBlockSize );
    my $numBlocks = int( $seqSize / $approxBlockSize ) + 1;
    my $blockAddl = 0;
    if ( $partialBlockSize < ( $approxBlockSize / 2 ) ) {

      # divide last block between all others
      $blockAddl = int( $partialBlockSize / $numBlocks );
    }

#print "approxBlockSize=$approxBlockSize, seqSize=$seqSize, PartialBlockSize = $partialBlockSize, numBlocks = $numBlocks, blockAddl=$blockAddl \n";

    my $seqRemaining = $seqSize;
    my $startPos     = 1;
    my $blockSize    = $approxBlockSize + $blockAddl;
    for ( my $i = 0 ; $i < $numBlocks ; $i++ ) {
      last if ( $blockSize >= $seqRemaining );
      push @sampleSourceList,
          {
            'seqID' => $seqID,
            'start' => $startPos,
            'end'   => $startPos + $blockSize - 1
          };

      #print "Adding: $seqID: $startPos-". ($startPos + $blockSize - 1). "\n";
      $seqRemaining -= $blockSize;
      $startPos += $blockSize;
    }
    if ( $seqRemaining > 0 ) {
      push @sampleSourceList,
          {
            'seqID' => $seqID,
            'start' => $startPos,
            'end'   => $startPos + $seqRemaining - 1
          };

      #print "Last: $seqID: $startPos-". ($startPos + $seqRemaining - 1). "\n";
    }
  }
  return \@sampleSourceList;
}

#
#  Given:
#      %dbSeqHashRef{ $seqID } = size :
#                   Sequence lengths for each ID.
#      $approxBlockSize : A suggested blocksize
#      $sampleSizeMax:    The maximum sample size
#      %usedSeqHashRef{ $seqID }->[ [start, end, round], [start, end, round] ]:
#                   A datastructure containing the use block lists
#                   (sorted) for each sequence.
#
#  - Randomly pick a chromosome ( FYS )
#  - Randomly pick a block ~blocksize large ( not already on
#    the used list ).
#  - Break on large string of N's and keep the bigger of the
#    two pieces.
#  - Append to fasta file with seqID and block range
#  - Keep going until we reach a specific size
#  - Convert fasta file into a XDF database.
#
# my $dbSourceBlocks->[]->{'seqID' =>
#                          'start' =>
#                          'end'   =>  };
sub sampleFromDB {
  my %parameters = @_;

  my $dbSourceBlocks = $parameters{'dbSourceBlocks'};
  my $dbUsedBlocks   = $parameters{'dbUsedBlocks'};
  my $sampleSizeMax  = $parameters{'sampleSizeMax'};
  my $dbFile         = $parameters{'dbFile'};
  my $dbType         = $parameters{'dbType'};
  my $fastaFile      = $parameters{'fastaFile'};
  my $round          = $parameters{'round'};
  my $prohibitX      = $parameters{'prohibitX'};

  open FASTA, ">$fastaFile";

  my $sampleSeqSize = 0;
  my @fastaBlocks   = ();
  my $giIndex       = 1;
  while (    $sampleSeqSize < $sampleSizeMax
          && $#{$dbSourceBlocks} >= 0 )
  {

    my $block = pop @{$dbSourceBlocks};

    my $seqID = $block->{'seqID'};
    my $start = $block->{'start'};
    my $end   = $block->{'end'};

    my $seqSize = $end - $start + 1;

    # Collect the sequence
    my $seq;
    if ( $dbType eq "abblast" ) {
      $seq = `$RepModelConfig::XDGET_PRGM -n -a$start -b$end $dbFile "$seqID"`;
      die $CLASS
          . "::sampleFromDB() Could not obtain sequence $seqID from"
          . " the database!\n"
          if ( $seq eq "" );
    }
    else {

      #my $openCoordEnd = $end+1;
      my $openCoordEnd   = $end;
      my $openCoordStart = $start - 1;
      if ( $seqID =~ /gi\|(\d+)/ ) {
        $seq =
`$RepModelConfig::NCBIDBCMD_PRGM -db $dbFile -entry $1 -range $openCoordStart-$openCoordEnd`;
      }
      die $CLASS
          . "::sampleFromDB() Could not obtain sequence ( entry = $1, "
          . "start = $openCoordStart end = $openCoordEnd ) from"
          . " the database!\n"
          if ( $seq eq "" );
    }

    # Removing header
    $seq =~ s/^>.*$//gm;

    # Remove spaces and line terminations
    $seq =~ s/[\n\r\s]+//g;

    # Collect stats
    my $numAmbiguous = ( $seq =~ tr/xnXN/xnXN/ );
    if ( length( $seq ) - $numAmbiguous < 100 ) {

      # Sequence is mostly ambiguous
      #  - discard but mark as used
      print "Discarding sequence because it's painfully small...\n"
          if ( $DEBUG );
      my $seq = "";
    }

    # TODO: Break up sequences on big "n" boundaries
    #s/^([nN]+)//;
    #my $startPos = $randStartPos + length( $1 );
    #while ( $seq =~ s/([^nN]+)([nN]{1000,})// ){
    #  push @frags, $1;
    #  push @fragStarts, $startPos;
    #  $startPos += length( $1.$2 );
    #}

    if ( $seq ) {
      $sampleSeqSize += length( $seq ) - $numAmbiguous;

      # Save sequence to file
      print FASTA ">gi|$giIndex " . "$dbFile-$seqID" . "_$start-$end\n";
      $giIndex++;
      $seq =~ s/[xX]/n/g if ( $prohibitX );
      $seq =~ s/(.{50})/$1\n/g;
      print FASTA "$seq\n";
    }

    push @dbUsedBlocks, $block;
    push @fastaBlocks,  $block;
  }
  close FASTA;

  return ( \@fastaBlocks );
}

sub fisherYatesShuffle {
  my $array = shift;
  my $i;
  for ( $i = @$array - 1 ; $i >= 0 ; --$i ) {
    my $j = int rand( $i + 1 );
    next if $i == $j;
    @$array[ $i, $j ] = @$array[ $j, $i ];
  }
}

##-------------------------------------------------------------------------##
## Use:  my ( $tempDir ) = &createTempDir( \@tmpPath );
##
##  Returns
##
##-------------------------------------------------------------------------##
sub createTempDir {
  my $tmpPathRef = shift;

  ## Get date
  my $date = localtime( time() );

  # Windows does not support the use of ":" in a filename.
  $date =~ s/[ ,\t,\n:]//g;

  my $runnumber = "$$" . ".$date";
  my $tempDir   = "";
  foreach my $directory ( @{$tmpPathRef} ) {

    if ( $directory =~ /\/$/ ) {
      $tempDir = $directory . "RM_$runnumber";
    }
    else {
      $tempDir = $directory . "/RM_$runnumber";
    }

    if ( -d "$tempDir" || mkdir $tempDir, 0777 ) {
      if ( open( IN, ">$tempDir/deleteMe" ) ) {
        close IN;
        unlink( "$tempDir/deleteMe" );
        last;
      }
    }
    $tempDir = "";
  }
  return ( $tempDir );
}

##-------------------------------------------------------------------------##
## Use: my $string = elapsedTime( $index );
##
##   Returns
##
##      Great little utility for measuring the elapsed
##      time between one or more sections of perl code.
##
##-------------------------------------------------------------------------##
sub elapsedTime {
  my ( $TimeHistIdx ) = @_;
  if ( defined $TimeBefore{$TimeHistIdx} ) {
    my $DiffTime = time - $TimeBefore{$TimeHistIdx};
    $TimeBefore{$TimeHistIdx} = time;
    my $Min = int( $DiffTime / 60 );
    $DiffTime -= $Min * 60;
    my $Hours = int( $Min / 60 );
    $Min -= $Hours * 60;
    my $Sec = $DiffTime;
    return "$Hours:$Min:$Sec Elapsed Time";
  }
  else {
    $TimeBefore{$TimeHistIdx} = time;
    return 0;
  }
}

1;

